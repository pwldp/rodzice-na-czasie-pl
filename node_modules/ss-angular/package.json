{
  "name": "ss-angular",
  "description": "Request responder and client side libraries for use of SocketStream 0.3.4+ as a back-end for AngularJS",
  "author": {
    "name": "Ben Polidore",
    "email": "polidore@gmail.com"
  },
  "version": "0.6.2",
  "main": "./lib/server/index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/polidore/ss-angular.git"
  },
  "engines": {
    "node": ">= 0.8.0"
  },
  "dependencies": {
    "apitree": "= 1.1.0"
  },
  "devDependencies": {},
  "readme": "# Approach\n\nCreate an angular service that can be injected into controllers similar to the angular REST resource library.\n\n# Installing\n\n* Create a new socketstream app\n* Edit its package.json to add `ss-angular` as a dependency:\n\n```javascript\n\"dependencies\": {\n  \"socketstream\": \"0.3.3\",\n  \"ss-angular\": \"0.x.x\"\n}\n```\n\n* run `npm install`\n* Reference the ss-angular request responder in your app.js:\n\n```javascript\nss.responders.add(require('ss-angular'));\n```\n\nThis will install the backend request responder, and inject the client library for models specifically and some other wrappers around existing SocketStream features for use in AngularJS.\n\nAdd the following to your `client/code/app/entry.js` above the `ss.server.on` line\n\n```javascript\nrequire('ssAngular');\nrequire('/controllers');\n```\n\nThen define your angular controllres in `client/code/app/controllers.js`\n\nYou also have to make sure that you have angular.js in your `client/code/lib`\n\n# Running Example\n\nIf you clone this repo, there is an example.  To run it, just cd to the example dir and run `npm install`\n\n# Model\n\nThis is the real value of this library.  If you declare a model in `server/model`, ss-angular will poll it every `pollFreq` seconds and push deltas to the client.  This is a read-only mechanism.  In the near future, updates will be incremental, but as of version 0.4, it just pushes the entire object on each update whether it has changed or not.  \n\nIt's implemented as a request responder, and it is similar to SocketStream's rpc library.  It supports middleware in the same manner as rpc as well.\n\n## Server\n\nDefine a model in the `server/model` directory. I called this one example.js:\n\n```javascript\n//des describes the model and has the middleware\n//chan is a channel on which to post the updated model object\n\nvar names = ['Tom','Dick','Harry'];\n\nexports.make = function(des,chan,ss) {\n  //des.use if middleware required\n  \n  return {\n    //must have a poll function for now. may have other update models\n    poll: function(where) { //where is a JSON where clause\n      var obj = {\n        hash: Math.floor(d.getSeconds() / 5.0), //only update every 5 seconds even though polled every second\n        hasBall: names[Math.floor(Math.random()*3-0.001)],\n        leadingBy: Math.floor(Math.random()*100),\n        serverTime: Date.now(),\n        filter: where //silly\n      };\n      chan(obj);\n    }\n  };\n};\n```\n\n## Client\n\nThis library does expose a raw ss API called `linkModel` and `unlinkModel`.  You just pass it the model name and parameters and it passes you back an object every N seconds.  From the ss-angular client library:\n\n```javascript\nss.linkModel(name, params, function(modelObj) {\n    scope[name] = modelObj;\n});\n```\n\nBut it's much more fun if you use it via angular! I've exposed a new API in the ssAngular module, and you can use it in angular controllers like this: \n\n```javascript\nangular.module('exampleApp', ['ssAngular'])\n  .controller('SSCtrl',['$scope','model',function($scope,model) {\n    $scope.linkModel('example',{id: 1234}, 'modelData'); \n      //this creates $scope.modelData and updates it with data in the example model filtered by id 1234\n      //the modelData param is optional. If omitted, the model will exists as 'example' on the scope.\n  }]);\n```\n\nIt's that simple.  You define your app's module, the ssAngular dependency and then inject model into your controller's dependencies.  In this case, example is the name of the file I created in `server/model` and it will be the name of the model on angular's $scope. Here's the html that uses this controller:\n\n\n```html\n<table>\n  <thead>\n    <tr>\n      <th>Has Ball</th>\n      <th>Leading By</th>\n      <th>Server Time</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>{{modelData.hasBall}}</td>\n      <td>{{modelData.leadingBy}}</td>\n      <td>{{modelData.serverTime}}</td>\n    </tr>\n  </tbody>\n</table>\n```\n\nThe data in curly brackets will be automatically updated.  The link is created by simply mentioning example in the `linkModel` command.\n\nImportant note: you can only subscribe to a named model once in a given scope, even if you use a different where clause.  The idea here is that scopes are fairly narrow, and I'd prefer to refer to the model data without the where clause for simplicity.  If I allow multiple subscriptions to the same model with different where clauses in the same scope, then I have to make you refer to the model by `name/where` and that's ugly in the HTML.  Just create a lot of scopes and keep your model context broad enough that it \"fills\" a scope.\n\nThe library will automatically unsubscribe from your model when the scope that created it is destroyed.\n\n# Authentication\n\nAngular doesn't have great support for authentication.  I added a few nice things that you can use to integrate with the sessions functionality in socket stream.  This logic works nicely with the angular `$routeProvider`. \n\n## Client\n\nDefine your routes and backend authentication service module:\n\n```javascript\nangular.module('exampleApp', ['ssAngular'])\n  .config(['authProvider','$routeProvider','$locationProvider',function(authProvider,$routeProvider,$locationProvider) {\n    authProvider.authServiceModule('example');\n    authProvider.loginPath('/login');\n    $routeProvider.\n      when('/login', {controller:'AuthCtrl', templateUrl:'login.html'}).\n      when('/app', {controller:'SSCtrl', templateUrl:'app.html'}).\n      otherwise({redirectTo:'/app'});\n    $locationProvider.html5Mode(true);\n  }])\n```\n\nThe login path is the path that users should be redirected to if they are not logged in.\n\nUse the auth.authenticate and auth.logout functions:\n\n```javascript\n  .controller('AuthCtrl',['$scope', '$location', '$log', 'auth', function($scope, $location, $log, auth) {\n    $scope.processAuth = function() {\n      $scope.showError = false;\n      var promise = auth.login($scope.user, $scope.password);\n      promise.then(function(reason) {\n        var newPath = '/app';\n        if($scope.redirectPath) {\n          newPath = $scope.redirectPath; //this is saved if ssAngular redirects to login due to lack of authentication\n        }\n        $location.path(newPath);\n      }, function(reason) {\n        $scope.showError = true;\n        $scope.errorMsg = \"Invalid login\";\n      });\n    };\n  });\n```\n\nThis is a controller for a form that asks the user for a username and password. It passes it to the server using the auth service and it awaits the response as a `$q` promise.\n\nFind out if the user is logged in using `$scope.authenticated`:\n\n```html\n<div ng-show=\"authenticated\">\n//...\n</div>\n```\n\nI put this around the template used for one of my routes.\n\n## Server\n\nIn the rpc file referenced in the configuration of the auth provider, you must have this interface: \n\n```javascript\n    authenticate: function(user,pass) {\n      ss.log(\"User\", user, \"Pass\", pass);\n      if(user === 'user' && pass === 'pass') {\n        ss.log(\"Successful login\");\n        req.session.setUserId(user);\n        res(true);\n      }\n      else {\n        ss.log(\"Access denied! The password is user/pass\");\n        res(false);\n      }\n    },\n    authenticated: function() { //this just returns whether the session is valid. allows the user to remain logged in after browser is closed\n      if(req.session.userId) {\n        res(true);\n      }\n      else {\n        res(false);\n      }\n    },\n    logout: function() {\n      req.session.setUserId(null);\n      res(true);\n    }\n```\n\n# Pub Sub\n\nOnce you have injected this module into your app and the pubsub service into your scope, you can simply create subscriptions to scope events using angular's API, and if they are prefixed with ss-, this library will subscribe for events from scoket stream with the same name.  When socketstream pushes events, they will be wrapped into Angular scope events on the appropriate scope. \n\nThis method allows you to target the events to the right part of your app and to keep in an \"angular\" mindset while gaining from socketstream. \n\nSee the example app.  The controller looks like this: \n\n```javascript\nangular.module('exampleApp', ['ssAngular'])\n  .controller('SSCtrl',['$scrope','pubsub',function($scope,pubsub) {\n    $scope.messages = []\n      $scope.$on('ss-example', function(event,msg) {\n        $scope.messages.push(msg);\n      });\n    }]);\n```\n\n# RPC\n\nThis is handled with the promise API in angular ($q).  You just assign a rpc call to a $scope object, and the value will be assigned when the rpc returns and the GUI updated.  You don't use a callback.  For example:\n\n```javascript\nangular.module('exampleApp', ['ssAngular'])\n  .controller('SSCtrl',['$scope','pubsub','rpc',function($scope,pubsub,rpc) {\n    $scope.streaming = false;\n    $scope.status = \"\";\n\n    $scope.toggleData = function() {\n      if(!$scope.streaming) {\n        $scope.streaming = true;\n        $scope.status = rpc('example.on');\n      }\n      else {\n        $scope.streaming = false;\n        $scope.status = rpc('example.off', 'Too random');\n      }\n    };\n  }]);\n```\n\nHere we're assigning the return value of the socketstream services we've defined to $scope.status directly. As you can see, you can pass params or not, but you can't define a callback.  If you really need a callback, just call socketstream directly!\n\n\n# License\n\nss-angular is released under the MIT license.\n",
  "readmeFilename": "README.md",
  "_id": "ss-angular@0.6.2",
  "_from": "ss-angular@>= 0.5.x"
}
